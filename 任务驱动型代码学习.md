# 任务驱动型代码学习

## task1 字节交换

抽象导航通信（tcp通信），串口通信（serialPort），和调试器通信（udp）

配置读取写入任务和，读写异常重启任务

### **1. TCP**

#### 大致框图

###### 面向过程

1. 创建socket文件描述符

2. 绑定端口号

3. 监听

4. 接受请求

5. 建立连接

6. 关闭套接字

###### 面向对象

1. 一个服务端：主服务， 端口，连接状态响应。需要-socket和接收器

2. 一个客户端： io服务，服务端， 端口（实现一连串的操作比如：解析， 查询， 解析，连接）

考虑到跨平台使用，所以我们使用第三方库 boost

实现的第一版只能发送连接指令：

```cpp
#include <iostream>
#include <boost/asio.hpp>

using boost::asio::ip::tcp;

// 服务端口
/**
* @brief 服务端口
* @note 这里面有：
*/
class Server {
public:
    // 破烂GPT,socket都不初始化
    Server(boost::asio::io_service& io_service, int port)
        : acceptor_(io_service, tcp::endpoint(tcp::v4(), port)), socket_(io_service) {
        start_accept();
    }

private:
    void start_accept() {
        // 然后这里不可可以使用共享指针创建套接字，这里在函数结束时自动释放
        tcp::socket socket = tcp::socket(acceptor_.get_executor());  //get_io_service()已经不能用了，破烂GPT
        acceptor_.async_accept(socket_,
            [this](boost::system::error_code ec) {
                if (!ec) {
                    std::cout << "Client Connected!" << "\n";
                }
                // 为下一个连接请求准备socket
                // socket_ = tcp::socket(acceptor_.get_io_service());
                start_accept();
            });
    }

    tcp::socket socket_;  // 服务端socket
    tcp::acceptor acceptor_;  // 服务端acceptor
};


//服务端试过之后我们尝试创建一个客户端，可以与服务端进行双向通信
class Client {
public:
    //同样需要一个io口服务，和一个服务端的ip地址和端口号
    //实现功能：连接到服务端，然后输出连接成功
    Client(boost::asio::io_service& io_service, const std::string& server, const std::string& port)  //端口有字符床
    : socket_(io_service){
        // 一连串的操作
        tcp::resolver resolver(io_service);   //解析器
        tcp::resolver::query query(server, port); //查询
        tcp::resolver::iterator endpoint_iterator = resolver.resolve(query); //解析
        boost::asio::connect(socket_, endpoint_iterator);  //连接
        std::cout << "Connect to Service!!" << "\n";
    }

private:
    tcp::socket socket_;  // 客户端socket

 };


int main() {
 //   //然后可以简单的试一下
    //try {
    //    boost::asio::io_service io_service;
    //    Server server(io_service, 12345);
    //    io_service.run();
    //}
    //catch (std::exception& e) {
    //    std::cerr << e.what() << std::endl;
    //}
    //现在使用多线程实现客户端和服务端的通信,实际上并不是这么做
    try {
        boost::asio::io_service io_service;
        std::thread server_thread([&io_service]() {
            Server server(io_service, 12345);
            io_service.run();
            }); // lambada 函数极大简洁了
        //std::thread client_thread([&io_service]() {
        //    Client client(io_service, "localhost", "12345");
        //    io_service.run();
        //    });
        server_thread.join();
        //client_thread.join();
    }
    catch (std::exception& e) {
        std::cerr << e.what() << std::endl;
    }


    return 0;
}


// 测试完毕，没有发现异常，到此简单的服务端和客户端的通信就建立了，但是还需要发送复杂的数据，需要进一步完善
// 先后关系： 客户端先连接，然后服务端口后接受消息
// 这代码好水，啥功能都没实现，明天继续改
```

好，现在我们觉得不够，所以继续加功能：我需要连接有一个响应，断开也要有一个响应，响应打印在操作台上，这时应该如何修改代码呢（io_service是程序与操作系统的桥梁）

之前没有补充，现在补上：就是要实现数据的收发，所以你需要先创建一个数据收发程序，检测收发情况判断连接情况

所以我们准备了一个dataSession的类

```cpp
class dataSession : public std::enable_shared_from_this<dataSession> {
public:
    dataSession(tcp::socket socket, boost::asio::io_context& io_context) : socket_(std::move(socket)), io_context(io_context) {}
    void start() {

        do_read();
    }
private:
    tcp::socket socket_;  // 服务端socket
    boost::asio::io_context& io_context;  //类内引用，共享
    enum { max_length = 256 };
    std::array<char, max_length> data_; //这里假装使用字符串 const char* 

    void do_read() {
        auto self(shared_from_this()); // 共享指针
        socket_.async_read_some(boost::asio::buffer(data_, max_length),
            [this, self](boost::system::error_code ec, std::size_t length) {
                if (!ec) {
                    std::cout << "Receive: " << std::string(data_.data(), length) << "\n";  //先看看不转化成字符串的效果: 屯屯屯。。。
                    do_write(length);
                }
                else {
                    std::cerr << "Read fail!" << ec.message() << "\n";
                    socket_.close();
                }
            });
    }
```

修改创建的套接字

```cpp
std::make_shared<dataSession>(std::move(socket_), static_cast<boost::asio::io_context&>(acceptor_.get_executor().context())) -> start();  //甚至可以在共享指针上面进行操作
```

### **2. UDP**


